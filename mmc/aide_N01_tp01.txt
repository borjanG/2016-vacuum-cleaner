La méthode applyChoix de World (classe dérivée de Monde)
a besoin de pouvoir modifier le contenu de la table et la position de l'agent

La méthode la plus simple permettant de faire cette opération sans modifier
les tests antérieurs (tp00a) consiste à transformer les variables privées
en variables protégées [ATTENTION on ne relache les contraintes que pour
table et posAgen]

Ainsi si dans Monde vous aviez fait

def __init__(self,agent,nbLignes=1,nbColonnes=2):
    ....
    self.initialisation()

def initialisation(self):
    self.__table = ...
    self.__position = ...

@property
def posAgent(self): return self.__position
@property
def table(self): return copy.deepcopy(self.__table)

Vous remplacez (partout dans le fichier self.__table par self._table et self.__position par self._position)

On obtient alors :

def __init__(self,agent,nbLignes=1,nbColonnes=2):
    ....
    self.initialisation()

def initialisation(self):
    self._table = ...
    self._position = ...

@property
def posAgent(self): return self._position
@property
def table(self): return copy.deepcopy(self._table)


En faisant ainsi les attributs table et posAgent sont toujours en lecture seule mais il est
maintenant possible d'accéder en écriture dans les classes dérivées (telle que World)

self._position = ...
self._table[ ][ ] = ...

====================================== prive_protege.py =====================================================

Création de u instance de Derivee
un=100 deux=200
le contenu de l'instance u {'_Base__b': 200, '_a': 100}
__________
acces en écriture sur u.un
> Erreur can't set attribute
non modifié un=100 deux=200
-------
acces en écriture sur u.deux
> Erreur can't set attribute
non modifié un=100 deux=200
-------
acces en écriture sur u._a
modifié un=42 deux=200
le contenu de l'instance u {'_Base__b': 200, '_a': 42}
-------
acces en écriture sur u.__b
modifié un=42 deux=200
le contenu de l'instance u {'__b': 42, '_Base__b': 200, '_a': 42}
-------


